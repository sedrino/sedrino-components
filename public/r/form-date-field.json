{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form-date-field",
  "type": "registry:component",
  "description": "A standalone date picker component.",
  "files": [
    {
      "path": "app/components/form/date-field.tsx",
      "content": "import { HTMLAttributes, useEffect, useState } from \"react\";\n\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\n\nexport type DateValue = Date | string | number | null | undefined; // number is unix timestamp in milliseconds\n\nexport type TimeSettings = {\n  hours?: number;\n  minutes?: number;\n  seconds?: number;\n  milliseconds?: number;\n};\n\n// Use a simple string with runtime validation instead of complex template literals\nexport type TimeString = string;\n\nexport type TimeValue = TimeSettings | TimeString | number; // string in HH:MM format, number in seconds\n\nexport type FormDateFieldProps<T extends DateValue = Date> = Omit<\n  HTMLAttributes<HTMLInputElement>,\n  \"value\" | \"onChange\"\n> & {\n  value: T;\n  onChange: (value: T) => void;\n  onBlur?: () => void;\n  id?: string;\n  label?: string;\n  disabled?: boolean;\n  className?: string;\n  min?: DateValue;\n  max?: DateValue;\n  as?: T extends Date ? \"date\" : T extends string ? \"iso\" : \"date\";\n  time?: TimeValue;\n  timezone?: string; // e.g. 'America/New_York', 'Europe/London'\n  clearable?: boolean;\n};\n\n// Convert DateValue to Temporal.PlainDate\nfunction toPlainDate(dateValue: DateValue): Temporal.PlainDate {\n  if (dateValue === null || dateValue === undefined) {\n    // Default to current date for null/undefined values - only for internal calculations\n    const now = new Date();\n    return Temporal.PlainDate.from({\n      year: now.getFullYear(),\n      month: now.getMonth() + 1,\n      day: now.getDate(),\n    });\n  }\n\n  if (dateValue instanceof Date) {\n    return Temporal.PlainDate.from({\n      year: dateValue.getFullYear(),\n      month: dateValue.getMonth() + 1, // JS Date is 0-indexed for months\n      day: dateValue.getDate(),\n    });\n  } else if (typeof dateValue === \"string\") {\n    return Temporal.PlainDate.from(dateValue);\n  } else {\n    // Convert unix timestamp to PlainDate\n    const date = new Date(dateValue);\n    return Temporal.PlainDate.from({\n      year: date.getFullYear(),\n      month: date.getMonth() + 1,\n      day: date.getDate(),\n    });\n  }\n}\n\n// Convert Temporal.PlainDate to ISO string format (YYYY-MM-DD)\nfunction plainDateToISOString(date: Temporal.PlainDate): string {\n  return date.toString();\n}\n\n// Convert TimeValue to Temporal.PlainTime\nfunction toPlainTime(timeValue?: TimeValue): Temporal.PlainTime {\n  if (!timeValue) {\n    // Default to 0 time if not provided\n    return Temporal.PlainTime.from({\n      hour: 0,\n      minute: 0,\n      second: 0,\n      millisecond: 0,\n    });\n  }\n\n  if (typeof timeValue === \"string\") {\n    try {\n      // Try to parse directly first\n      return Temporal.PlainTime.from(timeValue);\n    } catch (e) {\n      // If direct parsing fails, try with regex for common formats\n      if (/^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/.test(timeValue)) {\n        const parts = timeValue.split(\":\");\n        return Temporal.PlainTime.from({\n          hour: parseInt(parts[0], 10),\n          minute: parseInt(parts[1], 10),\n          second: parts.length > 2 ? parseInt(parts[2], 10) : 0,\n          millisecond: 0,\n        });\n      }\n      // If all parsing attempts fail, return default time\n      console.error(\"Invalid time string format:\", timeValue);\n      return Temporal.PlainTime.from({\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0,\n      });\n    }\n  } else if (typeof timeValue === \"number\") {\n    // Convert seconds since midnight to PlainTime\n    const hours = Math.floor(timeValue / 3600);\n    const minutes = Math.floor((timeValue % 3600) / 60);\n    const seconds = timeValue % 60;\n    return Temporal.PlainTime.from({\n      hour: hours,\n      minute: minutes,\n      second: seconds,\n    });\n  } else if (typeof timeValue === \"object\") {\n    return Temporal.PlainTime.from({\n      hour: timeValue.hours ?? 0,\n      minute: timeValue.minutes ?? 0,\n      second: timeValue.seconds ?? 0,\n      millisecond: timeValue.milliseconds ?? 0,\n    });\n  }\n\n  // Fallback to default time\n  return Temporal.PlainTime.from({\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n  });\n}\n\n// Create ZonedDateTime from PlainDate, PlainTime and timezone\nfunction createZonedDateTime(\n  plainDate: Temporal.PlainDate,\n  plainTime: Temporal.PlainTime,\n  timezone?: string,\n): Temporal.ZonedDateTime {\n  const timeZone = timezone || \"UTC\"; // Default to UTC\n  const plainDateTime = plainDate.toPlainDateTime(plainTime);\n  return plainDateTime.toZonedDateTime(timeZone);\n}\n\n// Convert from Temporal to DateValue output\nfunction temporalToOutput<T extends DateValue>(\n  temporal: Temporal.ZonedDateTime | Temporal.PlainDate,\n  originalValue: T,\n): T {\n  if (typeof originalValue === \"number\") {\n    // Convert to unix timestamp in milliseconds\n    if (temporal instanceof Temporal.ZonedDateTime) {\n      return temporal.epochMilliseconds as T;\n    } else {\n      // For PlainDate, create a ZonedDateTime first\n      const zdt = temporal\n        .toPlainDateTime({\n          hour: 0,\n          minute: 0,\n          second: 0,\n          millisecond: 0,\n        })\n        .toZonedDateTime(\"UTC\"); // Use UTC for consistency\n      return zdt.epochMilliseconds as T;\n    }\n  } else if (originalValue instanceof Date) {\n    if (temporal instanceof Temporal.ZonedDateTime) {\n      return new Date(temporal.epochMilliseconds) as T;\n    } else {\n      const isoString = temporal.toString();\n      return new Date(isoString) as T;\n    }\n  } else {\n    // Must be string\n    if (temporal instanceof Temporal.ZonedDateTime) {\n      return temporal.toString() as T;\n    } else {\n      return temporal.toString() as T;\n    }\n  }\n}\n\nfunction isValidISODate(value: string): boolean {\n  try {\n    Temporal.PlainDate.from(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction isValidTimeString(value: string): boolean {\n  try {\n    Temporal.PlainTime.from(value);\n    return true;\n  } catch {\n    return /^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/.test(value);\n  }\n}\n\nexport function FormDateField<T extends DateValue = Date>(\n  props: FormDateFieldProps<T>,\n) {\n  const {\n    value,\n    onChange,\n    onBlur,\n    id,\n    label,\n    disabled,\n    className,\n    min,\n    max,\n    as = (value instanceof Date\n      ? \"date\"\n      : typeof value === \"string\"\n        ? \"iso\"\n        : \"date\") as FormDateFieldProps<T>[\"as\"],\n    time,\n    timezone,\n    clearable = true,\n    ...restProps\n  } = props;\n\n  const [displayValue, setDisplayValue] = useState<string>(\"\");\n\n  // Keep the UI display in sync with the value\n  useEffect(() => {\n    if (value === null || value === undefined) {\n      setDisplayValue(\"\");\n      return;\n    }\n\n    try {\n      const plainDate = toPlainDate(value);\n      setDisplayValue(plainDateToISOString(plainDate));\n    } catch (e) {\n      console.error(\"Error converting date value:\", e);\n      setDisplayValue(\"\");\n    }\n  }, [value]);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    setDisplayValue(inputValue);\n\n    if (inputValue === \"\") {\n      if (clearable) {\n        // Preserve the original type (null or undefined)\n        if (value === null) {\n          (onChange as (value: null) => void)(null);\n        } else if (value === undefined) {\n          (onChange as (value: undefined) => void)(undefined);\n        } else {\n          // Default to null for other values when clearing\n          (onChange as (value: null) => void)(null);\n        }\n      }\n      return;\n    }\n\n    if (isValidISODate(inputValue)) {\n      try {\n        // Create Temporal.PlainDate from input\n        const plainDate = Temporal.PlainDate.from(inputValue);\n\n        // Convert time to Temporal.PlainTime (defaults to 0 time if not provided)\n        const plainTime = toPlainTime(time);\n\n        // Create a ZonedDateTime with UTC as default timezone\n        const zonedDateTime = createZonedDateTime(\n          plainDate,\n          plainTime,\n          timezone,\n        );\n\n        // Check min and max constraints if any\n        if (min !== undefined) {\n          const minPlainDate = toPlainDate(min);\n          if (Temporal.PlainDate.compare(plainDate, minPlainDate) < 0) return;\n        }\n\n        if (max !== undefined) {\n          const maxPlainDate = toPlainDate(max);\n          if (Temporal.PlainDate.compare(plainDate, maxPlainDate) > 0) return;\n        }\n\n        // Convert back to the original type\n        const outputValue = temporalToOutput<T>(\n          timezone || time ? zonedDateTime : plainDate,\n          value,\n        );\n\n        onChange(outputValue);\n      } catch (e) {\n        console.error(\"Error handling date change:\", e);\n      }\n    }\n  };\n\n  const handleBlur = () => {\n    // Empty value handling\n    if (displayValue === \"\") {\n      if (clearable) {\n        if (value === null || value === undefined) {\n          // Already cleared, do nothing\n        } else {\n          // Clear the value if not already cleared\n          if (value === null) {\n            (onChange as (value: null) => void)(null);\n          } else if (value === undefined) {\n            (onChange as (value: undefined) => void)(undefined);\n          } else {\n            // Default to null for other values\n            (onChange as (value: null) => void)(null);\n          }\n        }\n      } else {\n        // If not clearable, reset to last valid value\n        try {\n          const plainDate = toPlainDate(value);\n          setDisplayValue(plainDateToISOString(plainDate));\n        } catch {\n          setDisplayValue(\"\");\n        }\n      }\n      onBlur?.();\n      return;\n    }\n\n    // Invalid value handling\n    if (!isValidISODate(displayValue)) {\n      // Reset to last valid value\n      if (value === null || value === undefined) {\n        setDisplayValue(\"\");\n      } else {\n        try {\n          const plainDate = toPlainDate(value);\n          setDisplayValue(plainDateToISOString(plainDate));\n        } catch {\n          setDisplayValue(\"\");\n        }\n      }\n    }\n    onBlur?.();\n  };\n\n  return (\n    <div className={cn(\"space-y-2\", className)}>\n      {label && (\n        <label htmlFor={id} className=\"text-sm font-medium\">\n          {label}\n        </label>\n      )}\n      <Input\n        id={id}\n        type=\"date\"\n        value={displayValue}\n        onChange={handleChange}\n        onBlur={handleBlur}\n        disabled={disabled}\n        {...restProps}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "app/components/form/date-field.tsx"
    }
  ]
}