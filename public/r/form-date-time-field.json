{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form-date-time-field",
  "type": "registry:component",
  "description": "A standalone date and time picker component.",
  "files": [
    {
      "path": "app/components/form/date-time-field.tsx",
      "content": "import { HTMLAttributes, useEffect, useState } from \"react\";\n\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\n\nimport { TimeString, TimeValue } from \"./date-field\";\n\nexport type DateTimeValue = Date | string | number | null | undefined;\n\nexport type FormDateTimeFieldProps<T extends DateTimeValue = Date> = Omit<\n  HTMLAttributes<HTMLInputElement>,\n  \"value\" | \"onChange\"\n> & {\n  value: T;\n  onChange: (value: T) => void;\n  onBlur?: () => void;\n  id?: string;\n  label?: string;\n  disabled?: boolean;\n  className?: string;\n  min?: DateTimeValue;\n  max?: DateTimeValue;\n  as?: T extends Date ? \"date\" : T extends string ? \"iso\" : \"date\";\n  timezone?: string; // e.g. 'America/New_York', 'Europe/London', if not provided uses local browser timezone\n  clearable?: boolean;\n};\n\n// Get current timezone from browser\nfunction getCurrentTimezone(): string {\n  return Intl.DateTimeFormat().resolvedOptions().timeZone;\n}\n\n// Convert DateTimeValue to Temporal.ZonedDateTime (preserving timezone information)\nfunction toZonedDateTime(\n  dateValue: DateTimeValue,\n  timezone?: string,\n): Temporal.ZonedDateTime {\n  const resolvedTimezone = timezone || getCurrentTimezone();\n\n  if (dateValue === null || dateValue === undefined) {\n    // Default to current date/time in the target timezone for internal calculations\n    return Temporal.Now.zonedDateTimeISO(resolvedTimezone);\n  }\n\n  if (dateValue instanceof Date) {\n    // For Date objects, use the exact timestamp but interpret in the target timezone\n    return Temporal.Instant.fromEpochMilliseconds(\n      dateValue.getTime(),\n    ).toZonedDateTimeISO(resolvedTimezone);\n  } else if (typeof dateValue === \"string\") {\n    try {\n      // Try to parse as ISO string with timezone information\n      return Temporal.ZonedDateTime.from(dateValue);\n    } catch {\n      // If that fails, parse as PlainDateTime and then convert to the target timezone\n      try {\n        const plainDateTime = Temporal.PlainDateTime.from(dateValue);\n        return plainDateTime.toZonedDateTime(resolvedTimezone);\n      } catch (e) {\n        console.error(\"Failed to parse date string:\", dateValue);\n        // Fallback: current date/time in the target timezone\n        return Temporal.Now.zonedDateTimeISO(resolvedTimezone);\n      }\n    }\n  } else {\n    // For unix timestamp (milliseconds), convert to Instant then to ZonedDateTime\n    return Temporal.Instant.fromEpochMilliseconds(dateValue).toZonedDateTimeISO(\n      resolvedTimezone,\n    );\n  }\n}\n\n// Convert to PlainDateTime in user's timezone for the input element\nfunction zonedDateTimeToLocalPlainDateTime(\n  zdt: Temporal.ZonedDateTime,\n): Temporal.PlainDateTime {\n  return zdt.toPlainDateTime();\n}\n\n// Convert Temporal.PlainDateTime to ISO string format (YYYY-MM-DDTHH:MM) for the input\nfunction plainDateTimeToInputString(dateTime: Temporal.PlainDateTime): string {\n  return dateTime.toString().slice(0, 16); // Trim to just YYYY-MM-DDTHH:MM\n}\n\n// Convert from Temporal to DateTimeValue output\nfunction temporalToOutput<T extends DateTimeValue>(\n  temporal: Temporal.ZonedDateTime,\n  originalValue: T,\n): T {\n  if (typeof originalValue === \"number\") {\n    // Convert to unix timestamp in milliseconds\n    return temporal.epochMilliseconds as T;\n  } else if (originalValue instanceof Date) {\n    return new Date(temporal.epochMilliseconds) as T;\n  } else {\n    // Must be string - return ISO format\n    return temporal.toString() as T;\n  }\n}\n\nfunction isValidISODateTime(value: string): boolean {\n  try {\n    Temporal.PlainDateTime.from(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport function FormDateTimeField<T extends DateTimeValue = Date>(\n  props: FormDateTimeFieldProps<T>,\n) {\n  const {\n    value,\n    onChange,\n    onBlur,\n    id,\n    label,\n    disabled,\n    className,\n    min,\n    max,\n    as = (value instanceof Date\n      ? \"date\"\n      : typeof value === \"string\"\n        ? \"iso\"\n        : \"date\") as FormDateTimeFieldProps<T>[\"as\"],\n    timezone,\n    clearable = true,\n    ...restProps\n  } = props;\n\n  const [displayValue, setDisplayValue] = useState<string>(\"\");\n\n  // Keep the UI display in sync with the value\n  useEffect(() => {\n    if (value === null || value === undefined) {\n      setDisplayValue(\"\");\n      return;\n    }\n\n    try {\n      // Convert to ZonedDateTime in the specified or local timezone\n      const zonedDateTime = toZonedDateTime(value, timezone);\n\n      // Convert to local PlainDateTime for display in the input\n      const localDateTime = zonedDateTimeToLocalPlainDateTime(zonedDateTime);\n\n      // Format for the input element\n      setDisplayValue(plainDateTimeToInputString(localDateTime));\n    } catch (e) {\n      console.error(\"Error converting datetime value:\", e);\n      setDisplayValue(\"\");\n    }\n  }, [value, timezone]);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n    setDisplayValue(inputValue);\n\n    if (inputValue === \"\") {\n      if (clearable) {\n        // Preserve the original type (null or undefined)\n        if (value === null) {\n          (onChange as (value: null) => void)(null);\n        } else if (value === undefined) {\n          (onChange as (value: undefined) => void)(undefined);\n        } else {\n          // Default to null for other values when clearing\n          (onChange as (value: null) => void)(null);\n        }\n      }\n      return;\n    }\n\n    if (isValidISODateTime(inputValue)) {\n      try {\n        // Create PlainDateTime from input\n        const plainDateTime = Temporal.PlainDateTime.from(inputValue);\n\n        // Convert to ZonedDateTime in the user's timezone or specified timezone\n        const userTimezone = timezone || getCurrentTimezone();\n        const zonedDateTime = plainDateTime.toZonedDateTime(userTimezone);\n\n        // Check min and max constraints if any\n        if (min !== undefined) {\n          const minZonedDateTime = toZonedDateTime(min, timezone);\n          if (\n            zonedDateTime.epochMilliseconds < minZonedDateTime.epochMilliseconds\n          )\n            return;\n        }\n\n        if (max !== undefined) {\n          const maxZonedDateTime = toZonedDateTime(max, timezone);\n          if (\n            zonedDateTime.epochMilliseconds > maxZonedDateTime.epochMilliseconds\n          )\n            return;\n        }\n\n        // Convert back to the original type (will be Unix timestamp for numeric types)\n        const outputValue = temporalToOutput<T>(zonedDateTime, value);\n        onChange(outputValue);\n      } catch (e) {\n        console.error(\"Error handling datetime change:\", e);\n      }\n    }\n  };\n\n  const handleBlur = () => {\n    // Empty value handling\n    if (displayValue === \"\") {\n      if (clearable) {\n        if (value === null || value === undefined) {\n          // Already cleared, do nothing\n        } else {\n          // Clear the value if not already cleared\n          if (value === null) {\n            (onChange as (value: null) => void)(null);\n          } else if (value === undefined) {\n            (onChange as (value: undefined) => void)(undefined);\n          } else {\n            // Default to null for other values\n            (onChange as (value: null) => void)(null);\n          }\n        }\n      } else {\n        // If not clearable, reset to last valid value\n        try {\n          const zonedDateTime = toZonedDateTime(value, timezone);\n          const localDateTime =\n            zonedDateTimeToLocalPlainDateTime(zonedDateTime);\n          setDisplayValue(plainDateTimeToInputString(localDateTime));\n        } catch {\n          setDisplayValue(\"\");\n        }\n      }\n      onBlur?.();\n      return;\n    }\n\n    // Invalid value handling\n    if (!isValidISODateTime(displayValue)) {\n      // Reset to last valid value\n      if (value === null || value === undefined) {\n        setDisplayValue(\"\");\n      } else {\n        try {\n          const zonedDateTime = toZonedDateTime(value, timezone);\n          const localDateTime =\n            zonedDateTimeToLocalPlainDateTime(zonedDateTime);\n          setDisplayValue(plainDateTimeToInputString(localDateTime));\n        } catch {\n          setDisplayValue(\"\");\n        }\n      }\n    }\n    onBlur?.();\n  };\n\n  return (\n    <div className={cn(\"space-y-2\", className)}>\n      {label && (\n        <label htmlFor={id} className=\"text-sm font-medium\">\n          {label}\n        </label>\n      )}\n      <Input\n        id={id}\n        type=\"datetime-local\"\n        value={displayValue}\n        onChange={handleChange}\n        onBlur={handleBlur}\n        disabled={disabled}\n        {...restProps}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "app/components/form/date-time-field.tsx"
    }
  ]
}