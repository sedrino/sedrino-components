{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form-time-field",
  "type": "registry:component",
  "description": "A standalone time picker component.",
  "files": [
    {
      "path": "app/components/form/time-field.tsx",
      "content": "import { HTMLAttributes, useEffect, useState } from \"react\";\n\nimport { Input } from \"@/components/ui/input\";\nimport { cn } from \"@/lib/utils\";\n\nexport type TimeValue = number | string | null | undefined;\n\n// Enhanced type definitions with generics to maintain type consistency\nexport type FormTimeFieldProps<T extends TimeValue = number> = Omit<\n  HTMLAttributes<HTMLInputElement>,\n  \"value\" | \"onChange\"\n> & {\n  value: T;\n  onChange: (value: T) => void;\n  onBlur?: () => void;\n  id?: string;\n  label?: string;\n  disabled?: boolean;\n  className?: string;\n  min?: TimeValue;\n  max?: TimeValue;\n  clearable?: boolean;\n  as?: T extends number ? \"seconds\" : T extends string ? \"iso\" : \"seconds\";\n};\n\n/**\n * Convert a time value to seconds\n * - If the value is a number, it's assumed to already be in seconds\n * - If the value is a string in HH:MM format, it's converted to seconds\n * - If the value is null or undefined, returns 0\n */\nfunction convertToSeconds(timeValue: TimeValue): number {\n  if (timeValue === null || timeValue === undefined) return 0;\n  if (typeof timeValue === \"number\") return timeValue;\n\n  // Handle HH:MM format\n  try {\n    const [hours, minutes] = timeValue.split(\":\").map(Number);\n    if (isNaN(hours) || isNaN(minutes)) {\n      console.warn(\"Invalid time format:\", timeValue);\n      return 0;\n    }\n    return hours * 3600 + minutes * 60;\n  } catch (e) {\n    console.warn(\"Error parsing time:\", timeValue, e);\n    return 0;\n  }\n}\n\n/**\n * Convert seconds to HH:MM format for the time input\n * @param seconds The number of seconds to convert\n * @returns A string in the format \"HH:MM\"\n */\nfunction secondsToTimeFormat(seconds: number): string {\n  // Ensure we have a valid number\n  if (isNaN(seconds) || seconds < 0) {\n    console.warn(\"Invalid seconds value:\", seconds);\n    return \"00:00\";\n  }\n\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n\n  return `${hours.toString().padStart(2, \"0\")}:${minutes.toString().padStart(2, \"0\")}`;\n}\n\n/**\n * Check if a string is a valid HH:MM time format\n */\nfunction isValidTimeFormat(value: string): boolean {\n  return /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(value);\n}\n\nexport function FormTimeField<T extends TimeValue = number>(\n  props: FormTimeFieldProps<T>,\n) {\n  const {\n    value,\n    onChange,\n    onBlur,\n    id,\n    label,\n    disabled,\n    className,\n    min,\n    max,\n    clearable = true,\n    as = (typeof value === \"string\"\n      ? \"iso\"\n      : \"seconds\") as FormTimeFieldProps<T>[\"as\"],\n    ...restProps\n  } = props;\n\n  // Track the input display value\n  const [displayValue, setDisplayValue] = useState<string>(\"\");\n\n  // Sync the display with the actual value\n  useEffect(() => {\n    if (value === null || value === undefined) {\n      setDisplayValue(\"\");\n      return;\n    }\n\n    // For string values (HH:MM format)\n    if (typeof value === \"string\") {\n      // If it's already a valid time string, use it directly\n      if (isValidTimeFormat(value)) {\n        setDisplayValue(value);\n      } else {\n        console.warn(\"Invalid time string format:\", value);\n        setDisplayValue(\"00:00\");\n      }\n    } else if (typeof value === \"number\") {\n      // For number values, convert seconds to HH:MM for display\n      setDisplayValue(secondsToTimeFormat(value));\n    }\n  }, [value]);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n\n    // Always update display value for responsive UI\n    setDisplayValue(inputValue);\n\n    // If input is cleared and clearable is true, set to null/undefined\n    if (inputValue === \"\" && clearable) {\n      // Preserve the original type (null or undefined)\n      if (value === null) {\n        (onChange as (value: null) => void)(null);\n      } else if (value === undefined) {\n        (onChange as (value: undefined) => void)(undefined);\n      } else if (as === \"iso\" || typeof value === \"string\") {\n        // For string values, default to empty string when clearing\n        (onChange as (value: string) => void)(\"\" as any);\n      } else {\n        // For number values, default to null when clearing\n        (onChange as (value: null) => void)(null);\n      }\n      return;\n    }\n\n    if (isValidTimeFormat(inputValue)) {\n      if (\n        as === \"iso\" ||\n        typeof value === \"string\" ||\n        value === null ||\n        value === undefined\n      ) {\n        // String mode (HH:MM format) or null/undefined converted to string based on 'as' prop\n        // Check min/max constraints\n        const secondsValue = convertToSeconds(inputValue);\n        const minSeconds =\n          min !== undefined ? convertToSeconds(min) : undefined;\n        const maxSeconds =\n          max !== undefined ? convertToSeconds(max) : undefined;\n\n        if (minSeconds !== undefined && secondsValue < minSeconds) return;\n        if (maxSeconds !== undefined && secondsValue > maxSeconds) return;\n\n        // Return the HH:MM string\n        (onChange as (value: string) => void)(inputValue as any);\n      } else {\n        // Number mode (seconds)\n        // Convert HH:MM to seconds\n        const secondsValue = convertToSeconds(inputValue);\n\n        // Check min/max constraints\n        const minSeconds =\n          min !== undefined ? convertToSeconds(min) : undefined;\n        const maxSeconds =\n          max !== undefined ? convertToSeconds(max) : undefined;\n\n        if (minSeconds !== undefined && secondsValue < minSeconds) return;\n        if (maxSeconds !== undefined && secondsValue > maxSeconds) return;\n\n        // Return seconds\n        (onChange as (value: number) => void)(secondsValue as any);\n      }\n    }\n  };\n\n  const handleBlur = () => {\n    // If display is empty and clearable, keep it empty\n    if (displayValue === \"\" && clearable) {\n      if (value === null || value === undefined) {\n        // Already cleared, do nothing\n      } else {\n        // Clear the value if not already cleared\n        if (value === null) {\n          (onChange as (value: null) => void)(null);\n        } else if (value === undefined) {\n          (onChange as (value: undefined) => void)(undefined);\n        } else if (as === \"iso\" || typeof value === \"string\") {\n          // For string values, default to empty string when clearing\n          (onChange as (value: string) => void)(\"\" as any);\n        } else {\n          // For number values, default to null when clearing\n          (onChange as (value: null) => void)(null);\n        }\n      }\n      onBlur?.();\n      return;\n    }\n\n    // On blur, if the current input is invalid, reset to the last valid value\n    if (!isValidTimeFormat(displayValue)) {\n      if (value === null || value === undefined) {\n        setDisplayValue(\"\");\n      } else if (typeof value === \"number\") {\n        setDisplayValue(secondsToTimeFormat(value as number));\n      } else if (\n        typeof value === \"string\" &&\n        isValidTimeFormat(value as string)\n      ) {\n        setDisplayValue(value as string);\n      } else {\n        setDisplayValue(\"00:00\");\n      }\n    }\n    onBlur?.();\n  };\n\n  return (\n    <div className={cn(\"space-y-2\", className)}>\n      {label && (\n        <label htmlFor={id} className=\"text-sm font-medium\">\n          {label}\n        </label>\n      )}\n      <Input\n        id={id}\n        type=\"time\"\n        value={displayValue}\n        onChange={handleChange}\n        onBlur={handleBlur}\n        disabled={disabled}\n        placeholder=\"HH:MM\"\n        {...restProps}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "app/components/form/time-field.tsx"
    }
  ]
}